<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Among Us - 2D Canvas Clone</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            font-family: 'Verdana', sans-serif;
            touch-action: none; 
            user-select: none;
        }

        #gameCanvas { display: block; }

        /* UI Overlays */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 240px;
            height: 170px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #777;
            border-radius: 8px;
            pointer-events: none;
            z-index: 50;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        .hud-btn {
            pointer-events: auto;
            position: absolute;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            color: white;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            backdrop-filter: blur(4px);
            transition: transform 0.1s, background 0.2s;
        }

        .hud-btn:active {
            transform: scale(0.9);
            background: rgba(255, 255, 255, 0.4);
        }

        #action-btn { bottom: 30px; right: 30px; width: 80px; height: 80px; font-size: 14px; text-transform: uppercase; }
        #kill-btn { bottom: 30px; right: 130px; width: 80px; height: 80px; color: #ff4444; border-color: #ff4444; display: none; }
        #vent-btn { bottom: 120px; right: 30px; width: 60px; height: 60px; display: none; }
        #role-toggle { top: 20px; left: 20px; width: auto; height: 40px; border-radius: 20px; padding: 0 20px; font-size: 14px; background: rgba(0,0,0,0.5); }

        #task-bar-container {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 30px;
            background: rgba(50, 50, 50, 0.8);
            border: 2px solid #fff;
            border-radius: 5px;
            overflow: hidden;
        }
        
        #task-bar-fill {
            height: 100%;
            width: 0%;
            background: #43d854;
            transition: width 0.1s linear;
        }

        #message-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 100;
        }

        #message-title {
            font-size: 4rem;
            font-weight: 900;
            margin-bottom: 20px;
            text-transform: uppercase;
            text-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        
        .crewmate-text { color: #8cffff; }
        .impostor-text { color: #ff4d4d; }

        #restart-btn {
            padding: 15px 40px;
            font-size: 1.5rem;
            background: white;
            color: black;
            border: none;
            cursor: pointer;
            border-radius: 5px;
            font-weight: bold;
        }

        #joystick-zone {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 150px;
            height: 150px;
            pointer-events: auto;
        }

        #controls-hint {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.5);
            font-size: 12px;
            pointer-events: none;
        }

    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <canvas id="minimap" width="240" height="170"></canvas>
        <div id="task-bar-container"><div id="task-bar-fill"></div></div>
        <div id="role-toggle" class="hud-btn" onclick="game.toggleRole()">Role: Crewmate</div>
        
        <div id="kill-btn" class="hud-btn" onmousedown="game.tryKill()" ontouchstart="game.tryKill()">KILL (F)</div>
        <div id="vent-btn" class="hud-btn" onmousedown="game.tryVent()" ontouchstart="game.tryVent()">VENT (V)</div>
        <div id="action-btn" class="hud-btn" onmousedown="game.startAction()" onmouseup="game.endAction()" ontouchstart="game.startAction()" ontouchend="game.endAction()">USE</div>

        <div id="joystick-zone"></div>
        <div id="controls-hint">WASD to Move | SPACE to Use | F to Kill | V to Vent</div>
    </div>

    <div id="message-overlay">
        <div id="message-title">VICTORY</div>
        <button id="restart-btn" onclick="game.reset()">PLAY AGAIN</button>
    </div>

<script>
// --- Constants & Config ---
const COLORS = {
    red: '#C51111', blue: '#132ED1', green: '#117F2D', 
    pink: '#ED54BA', orange: '#EF7D0D', yellow: '#F5F557',
    black: '#3F474E', white: '#D6E0F0', purple: '#6B2FBC',
    cyan: '#38FEDC', brown: '#71491E', lime: '#50EF39'
};

const WALL_COLOR = '#424858';
const FLOOR_COLOR = '#191c23';
const PLAYER_SPEED = 300; 
const NPC_SPEED = 180;
const KILLER_SPEED = 230; 
const PLAYER_RADIUS = 18;
const ROOM_WIDTH = 1200;
const ROOM_HEIGHT = 850;
const GRID_ROWS = 3;
const GRID_COLS = 3;
const MAP_WIDTH = ROOM_WIDTH * GRID_COLS;
const MAP_HEIGHT = ROOM_HEIGHT * GRID_ROWS;

// --- PATHFINDING ---
class Pathfinder {
    constructor(mapW, mapH, walls) {
        this.cellSize = 60; // Coarse grid for performance
        this.cols = Math.ceil(mapW / this.cellSize);
        this.rows = Math.ceil(mapH / this.cellSize);
        this.grid = new Uint8Array(this.cols * this.rows); // 0 = Walkable, 1 = Wall

        // Bake Walls into Grid
        for (let w of walls) {
            // Add padding to walls for entity radius
            const padding = 20; 
            const startCol = Math.floor((w.x - padding) / this.cellSize);
            const endCol = Math.floor((w.x + w.w + padding) / this.cellSize);
            const startRow = Math.floor((w.y - padding) / this.cellSize);
            const endRow = Math.floor((w.y + w.h + padding) / this.cellSize);

            for (let r = startRow; r <= endRow; r++) {
                for (let c = startCol; c <= endCol; c++) {
                    if (r >= 0 && r < this.rows && c >= 0 && c < this.cols) {
                        this.grid[r * this.cols + c] = 1;
                    }
                }
            }
        }
    }

    findPath(sx, sy, ex, ey) {
        const startNode = {
            c: Math.floor(sx / this.cellSize),
            r: Math.floor(sy / this.cellSize),
            g: 0, h: 0, parent: null
        };
        const endC = Math.floor(ex / this.cellSize);
        const endR = Math.floor(ey / this.cellSize);

        // Bounds check
        if (startNode.c < 0 || startNode.c >= this.cols || startNode.r < 0 || startNode.r >= this.rows) return [];
        if (endC < 0 || endC >= this.cols || endR < 0 || endR >= this.rows) return [];
        
        // Optim: If direct line of sight or very close, minimal path
        if (Math.abs(startNode.c - endC) + Math.abs(startNode.r - endR) < 2) {
            return [{x: ex, y: ey}];
        }

        let openList = [startNode];
        let closedSet = new Set();
        let cameFrom = new Map(); // Key: "c,r", Value: parentNode

        // Limit iterations to prevent lags
        let iterations = 0;
        const maxIterations = 500; 

        while (openList.length > 0 && iterations < maxIterations) {
            iterations++;
            // Sort by F cost (g + h) - simplified, usually use heap
            openList.sort((a, b) => (a.g + a.h) - (b.g + b.h));
            let current = openList.shift();
            const key = current.c + "," + current.r;

            if (current.c === endC && current.r === endR) {
                // Reconstruct
                let path = [];
                let curr = current;
                while (curr) {
                    // Convert grid center to world coords
                    path.unshift({
                        x: curr.c * this.cellSize + this.cellSize/2, 
                        y: curr.r * this.cellSize + this.cellSize/2
                    });
                    curr = curr.parent;
                }
                // Smooth: Replace start with actual start, end with actual end
                path[0] = {x: sx, y: sy}; // Optional, helps visual start
                path[path.length-1] = {x: ex, y: ey};
                // Remove start pos from path list so we move to next
                path.shift();
                return path;
            }

            closedSet.add(key);

            // Neighbors
            const dirs = [[0,1], [0,-1], [1,0], [-1,0]];
            for (let d of dirs) {
                const nc = current.c + d[0];
                const nr = current.r + d[1];
                const nKey = nc + "," + nr;

                if (nc >= 0 && nc < this.cols && nr >= 0 && nr < this.rows) {
                    if (this.grid[nr * this.cols + nc] === 1) continue; // Wall
                    if (closedSet.has(nKey)) continue;

                    const gScore = current.g + 1;
                    let existing = openList.find(n => n.c === nc && n.r === nr);

                    if (!existing) {
                        const hScore = Math.abs(nc - endC) + Math.abs(nr - endR); // Manhattan
                        openList.push({ c: nc, r: nr, g: gScore, h: hScore, parent: current });
                    } else if (gScore < existing.g) {
                        existing.g = gScore;
                        existing.parent = current;
                    }
                }
            }
        }
        
        // If fail or timeout, just try direct
        return [{x: ex, y: ey}];
    }
}

// --- Input Handling ---
class InputHandler {
    constructor() {
        this.keys = {};
        this.joystick = { x: 0, y: 0, active: false };
        
        window.addEventListener('keydown', e => this.keys[e.code] = true);
        window.addEventListener('keyup', e => {
            this.keys[e.code] = false;
            if (e.code === 'KeyF') game.tryKill();
            if (e.code === 'KeyV') game.tryVent();
            if (e.code === 'Space') game.endAction();
        });
        window.addEventListener('keydown', e => {
            if (e.code === 'Space') game.startAction();
        });

        const zone = document.getElementById('joystick-zone');
        let startX, startY;

        zone.addEventListener('touchstart', e => {
            e.preventDefault();
            const touch = e.touches[0];
            startX = touch.clientX;
            startY = touch.clientY;
            this.joystick.active = true;
        }, {passive: false});

        zone.addEventListener('touchmove', e => {
            e.preventDefault();
            if (!this.joystick.active) return;
            const touch = e.touches[0];
            const dx = touch.clientX - startX;
            const dy = touch.clientY - startY;
            const distance = Math.sqrt(dx*dx + dy*dy);
            const maxDist = 40;
            const force = Math.min(distance, maxDist) / maxDist;
            const angle = Math.atan2(dy, dx);
            this.joystick.x = Math.cos(angle) * force;
            this.joystick.y = Math.sin(angle) * force;
        }, {passive: false});

        const endTouch = (e) => {
            e.preventDefault();
            this.joystick.active = false;
            this.joystick.x = 0;
            this.joystick.y = 0;
        };
        zone.addEventListener('touchend', endTouch);
        zone.addEventListener('touchcancel', endTouch);
    }

    getMovement() {
        let dx = 0, dy = 0;
        if (this.keys['KeyW'] || this.keys['ArrowUp']) dy -= 1;
        if (this.keys['KeyS'] || this.keys['ArrowDown']) dy += 1;
        if (this.keys['KeyA'] || this.keys['ArrowLeft']) dx -= 1;
        if (this.keys['KeyD'] || this.keys['ArrowRight']) dx += 1;

        if (this.joystick.active) {
            dx = this.joystick.x;
            dy = this.joystick.y;
        } else if (dx !== 0 || dy !== 0) {
            const len = Math.sqrt(dx*dx + dy*dy);
            dx /= len; dy /= len;
        }
        return { x: dx, y: dy };
    }
}

// --- Entities ---

class Entity {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.radius = PLAYER_RADIUS;
        this.dead = false;
        this.direction = 1;
        this.isMoving = false;
        this.walkCycle = 0;
        
        // AI Pathing
        this.path = [];
        this.pathTimer = 0;
    }

    draw(ctx) {
        if (this.dead) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.ellipse(0, 10, 12, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#eee';
            ctx.fillRect(-3, -5, 6, 15);
            ctx.beginPath();
            ctx.arc(-4, -5, 4, 0, Math.PI*2);
            ctx.arc(4, -5, 4, 0, Math.PI*2);
            ctx.fill();
            ctx.restore();
            return;
        }

        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.scale(this.direction, 1);

        // Walking Animation
        if (this.isMoving) this.walkCycle += 0.2;
        const bob = Math.sin(this.walkCycle) * 2;
        const legL = Math.sin(this.walkCycle) * 4;
        const legR = Math.sin(this.walkCycle + Math.PI) * 4;

        // Backpack
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.roundRect(-22, -10 + bob, 10, 25, 4); 
        ctx.fill();
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 3;
        ctx.stroke();

        // Body
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.moveTo(-15, -20 + bob);
        ctx.lineTo(15, -20 + bob);
        ctx.bezierCurveTo(25, -20 + bob, 25, 20 + bob, 15, 20 + bob);
        ctx.lineTo(-15, 20 + bob);
        ctx.bezierCurveTo(-25, 20 + bob, -25, -20 + bob, -15, -20 + bob);
        ctx.fill();
        ctx.stroke();

        // Legs
        ctx.beginPath();
        ctx.roundRect(-15 + legL, 15 + bob, 10, 12, 4);
        ctx.roundRect(5 + legR, 15 + bob, 10, 12, 4);
        ctx.fill();
        ctx.stroke();

        // Visor
        ctx.fillStyle = '#9BE9F0';
        ctx.beginPath();
        ctx.ellipse(8, -8 + bob, 12, 9, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.ellipse(10, -11 + bob, 6, 3, 0.2, 0, Math.PI * 2);
        ctx.globalAlpha = 0.6;
        ctx.fill();
        ctx.globalAlpha = 1.0;

        ctx.restore();
    }

    // Helper for AI movement
    followPath(speed, dt, walls) {
        if (this.path.length === 0) return;

        const target = this.path[0];
        const dx = target.x - this.x;
        const dy = target.y - this.y;
        const dist = Math.sqrt(dx*dx + dy*dy);

        if (dist < 10) {
            this.path.shift(); // Reached waypoint
            return;
        }

        // Normalize
        const moveX = (dx / dist) * speed * dt;
        const moveY = (dy / dist) * speed * dt;

        this.isMoving = true;
        if (dx < 0) this.direction = -1; else this.direction = 1;

        // Collision Check (still needed for dynamic obstacles or sliding)
        if (!this.checkCollision(this.x + moveX, this.y, walls)) this.x += moveX;
        if (!this.checkCollision(this.x, this.y + moveY, walls)) this.y += moveY;
    }

    checkCollision(x, y, walls) {
        for (let w of walls) {
            let testX = Math.max(w.x, Math.min(x, w.x + w.w));
            let testY = Math.max(w.y, Math.min(y, w.y + w.h));
            if (Math.hypot(x - testX, y - testY) <= this.radius) return true;
        }
        return false;
    }
}

class Player extends Entity {
    constructor(x, y, color) {
        super(x, y, color);
        this.isImpostor = false;
        this.inVent = false;
    }

    update(dt, input, walls) {
        if (this.dead || this.inVent) {
            this.isMoving = false;
            return;
        }

        const move = input.getMovement();
        this.isMoving = (move.x !== 0 || move.y !== 0);

        if (move.x < 0) this.direction = -1;
        if (move.x > 0) this.direction = 1;

        let speed = PLAYER_SPEED;
        let nextX = this.x + move.x * speed * dt;
        let nextY = this.y + move.y * speed * dt;

        if (!this.checkCollision(nextX, this.y, walls)) this.x = nextX;
        if (!this.checkCollision(this.x, nextY, walls)) this.y = nextY;
        
        this.x = Math.max(20, Math.min(MAP_WIDTH - 20, this.x));
        this.y = Math.max(20, Math.min(MAP_HEIGHT - 20, this.y));
    }
}

class CrewmateNPC extends Entity {
    constructor(x, y, color) {
        super(x, y, color);
        this.state = 'IDLE'; 
        this.timer = 0;
        this.target = {x: 0, y: 0};
    }

    update(dt, walls, player, tasks, pathfinder) {
        if (this.dead) return;

        // 1. Check Fear
        const distToPlayer = Math.hypot(this.x - player.x, this.y - player.y);
        const isFleeing = (player.isImpostor && !player.inVent && !player.dead && distToPlayer < 250);

        if (isFleeing) {
            this.state = 'FLEE';
            this.path = []; // Clear current task path
        } else if (this.state === 'FLEE') {
            this.state = 'IDLE';
        }

        // 2. State Logic
        if (this.state === 'FLEE') {
            // Simple flee away from player (no pathfinding, just run)
            let dx = this.x - player.x;
            let dy = this.y - player.y;
            let len = Math.sqrt(dx*dx + dy*dy);
            if (len > 0) {
                // Move directly away, but slide against walls
                let speed = NPC_SPEED * 1.5;
                let moveX = (dx/len) * speed * dt;
                let moveY = (dy/len) * speed * dt;
                
                this.isMoving = true;
                if (moveX < 0) this.direction = -1; else this.direction = 1;

                if (!this.checkCollision(this.x + moveX, this.y, walls)) this.x += moveX;
                else if(Math.random()>0.5) this.y += speed*dt; // Panic wiggle

                if (!this.checkCollision(this.x, this.y + moveY, walls)) this.y += moveY;
                else if(Math.random()>0.5) this.x += speed*dt;
            }
        } 
        else if (this.state === 'IDLE') {
            this.timer -= dt;
            this.isMoving = false;
            if (this.timer <= 0) {
                // Pick a task
                const randomTask = tasks[Math.floor(Math.random() * tasks.length)];
                this.target = { x: randomTask.x, y: randomTask.y };
                // Calculate path
                this.path = pathfinder.findPath(this.x, this.y, this.target.x, this.target.y);
                this.state = 'MOVE';
            }
        } 
        else if (this.state === 'MOVE') {
            if (this.path.length > 0) {
                this.followPath(NPC_SPEED, dt, walls);
            } else {
                // Reached target
                this.state = 'WORK';
                this.timer = 3 + Math.random() * 4; 
                this.isMoving = false;
            }
        }
        else if (this.state === 'WORK') {
            this.timer -= dt;
            this.isMoving = false;
            if (Math.random() > 0.95) this.direction *= -1; // Idle look
            if (this.timer <= 0) {
                this.state = 'IDLE';
                this.timer = 1 + Math.random() * 2;
            }
        }
    }
}

class Killer extends Entity {
    constructor(x, y) {
        super(x, y, COLORS.red); // Standard Red Color
        this.radius = 18; 
        this.pathRefreshTimer = 0;
    }

    // Removed custom Draw() so it uses Entity.draw() (Standard Bean Model)

    update(dt, player, walls, pathfinder) {
        if (player.isImpostor || player.dead) {
            this.isMoving = false;
            return;
        }

        const dist = Math.hypot(player.x - this.x, player.y - this.y);

        if (dist < 30) {
            player.dead = true;
            game.gameOver("DEFEAT", "impostor-text");
        }

        // Re-calculate path to player every 0.5s
        this.pathRefreshTimer -= dt;
        if (this.pathRefreshTimer <= 0) {
            this.path = pathfinder.findPath(this.x, this.y, player.x, player.y);
            this.pathRefreshTimer = 0.5;
        }

        if (this.path.length > 0) {
            this.followPath(KILLER_SPEED, dt, walls);
        } else {
            // Fallback direct movement if path fails or close
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            if (dist > 0) {
                this.isMoving = true;
                if (dx < 0) this.direction = -1; else this.direction = 1;
                const vx = (dx/dist) * KILLER_SPEED * dt;
                const vy = (dy/dist) * KILLER_SPEED * dt;
                if (!this.checkCollision(this.x + vx, this.y, walls)) this.x += vx;
                if (!this.checkCollision(this.x, this.y + vy, walls)) this.y += vy;
            }
        }
    }
}

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.miniCanvas = document.getElementById('minimap');
        this.miniCtx = this.miniCanvas.getContext('2d');
        this.input = new InputHandler();
        
        this.resize();
        window.addEventListener('resize', () => this.resize());

        this.createFloorPattern();
        this.setupMap();
        
        // Initialize Pathfinder
        this.pathfinder = new Pathfinder(MAP_WIDTH, MAP_HEIGHT, this.walls);

        this.reset();

        this.actionHeld = false;
        this.taskProgress = 0;
        this.taskTarget = null;
        
        this.lastTime = Date.now();
        requestAnimationFrame(() => this.loop());
    }

    createFloorPattern() {
        const pCanvas = document.createElement('canvas');
        pCanvas.width = 100;
        pCanvas.height = 100;
        const pCtx = pCanvas.getContext('2d');
        pCtx.fillStyle = '#1a1d26';
        pCtx.fillRect(0, 0, 100, 100);
        pCtx.strokeStyle = '#252936';
        pCtx.lineWidth = 2;
        pCtx.beginPath();
        pCtx.moveTo(0, 0); pCtx.lineTo(100, 0);
        pCtx.moveTo(0, 50); pCtx.lineTo(100, 50);
        pCtx.moveTo(0, 0); pCtx.lineTo(0, 100);
        pCtx.moveTo(50, 0); pCtx.lineTo(50, 100);
        pCtx.stroke();
        pCtx.fillStyle = '#15171e';
        pCtx.beginPath();
        pCtx.arc(50, 50, 4, 0, Math.PI*2);
        pCtx.fill();
        this.floorPattern = this.ctx.createPattern(pCanvas, 'repeat');
    }

    setupMap() {
        this.walls = [];
        this.tasks = [];
        this.vents = [];
        for (let row = 0; row < GRID_ROWS; row++) {
            for (let col = 0; col < GRID_COLS; col++) {
                this.createRoom(col, row);
            }
        }
    }

    createRoom(gx, gy) {
        const offX = gx * ROOM_WIDTH;
        const offY = gy * ROOM_HEIGHT;
        const doorSize = 200;

        // Furniture
        this.walls.push({x: offX + 400, y: offY + 300, w: 100, h: 50}); 
        this.walls.push({x: offX + 700, y: offY + 300, w: 100, h: 50}); 
        this.walls.push({x: offX + 300, y: offY + 500, w: 100, h: 300}); 
        this.walls.push({x: offX + 800, y: offY + 500, w: 100, h: 300}); 
        this.walls.push({x: offX + 300, y: offY + 50, w: 100, h: 150});  
        this.walls.push({x: offX + 800, y: offY + 50, w: 100, h: 150});  
        this.walls.push({x: offX + 50, y: offY + 350, w: 150, h: 20});
        this.walls.push({x: offX + 1000, y: offY + 350, w: 150, h: 20});

        // Walls logic
        if (gy > 0) {
            this.walls.push({x: offX, y: offY, w: (ROOM_WIDTH - doorSize)/2, h: 50});
            this.walls.push({x: offX + (ROOM_WIDTH + doorSize)/2, y: offY, w: (ROOM_WIDTH - doorSize)/2, h: 50});
        } else { this.walls.push({x: offX, y: offY, w: ROOM_WIDTH, h: 50}); }
        
        if (gy < GRID_ROWS - 1) {
            this.walls.push({x: offX, y: offY + ROOM_HEIGHT - 50, w: (ROOM_WIDTH - doorSize)/2, h: 50});
            this.walls.push({x: offX + (ROOM_WIDTH + doorSize)/2, y: offY + ROOM_HEIGHT - 50, w: (ROOM_WIDTH - doorSize)/2, h: 50});
        } else { this.walls.push({x: offX, y: offY + ROOM_HEIGHT - 50, w: ROOM_WIDTH, h: 50}); }

        if (gx > 0) {
            this.walls.push({x: offX, y: offY, w: 50, h: (ROOM_HEIGHT - doorSize)/2});
            this.walls.push({x: offX, y: offY + (ROOM_HEIGHT + doorSize)/2, w: 50, h: (ROOM_HEIGHT - doorSize)/2});
        } else { this.walls.push({x: offX, y: offY, w: 50, h: ROOM_HEIGHT}); }

        if (gx < GRID_COLS - 1) {
            this.walls.push({x: offX + ROOM_WIDTH - 50, y: offY, w: 50, h: (ROOM_HEIGHT - doorSize)/2});
            this.walls.push({x: offX + ROOM_WIDTH - 50, y: offY + (ROOM_HEIGHT + doorSize)/2, w: 50, h: (ROOM_HEIGHT - doorSize)/2});
        } else { this.walls.push({x: offX + ROOM_WIDTH - 50, y: offY, w: 50, h: ROOM_HEIGHT}); }

        // Tasks
        this.tasks.push({x: offX + 100, y: offY + 700, color: 'yellow', completed: false});
        this.tasks.push({x: offX + 1100, y: offY + 100, color: 'cyan', completed: false});
        this.tasks.push({x: offX + 600, y: offY + 100, color: 'lime', completed: false});
        this.tasks.push({x: offX + 600, y: offY + 750, color: 'pink', completed: false});

        // Vents
        const baseId = (gy * GRID_COLS + gx) * 10;
        this.vents.push({id: baseId + 1, x: offX + 100, y: offY + 100, link: baseId + 2});
        this.vents.push({id: baseId + 2, x: offX + 1100, y: offY + 750, link: baseId + 3});
        this.vents.push({id: baseId + 3, x: offX + 100, y: offY + 750, link: baseId + 1});
    }

    reset() {
        this.player = new Player(ROOM_WIDTH * 1.5, ROOM_HEIGHT * 1.5, COLORS.red);
        this.entities = [];
        this.killers = [];
        
        this.tasks.forEach(t => t.completed = false);
        this.totalTasks = this.tasks.length;
        this.completedTasks = 0;
        this.updateTaskBar();
        
        // Spawn Smart Crewmates
        const colors = Object.values(COLORS);
        for(let i=0; i < 20; i++) {
            const rx = Math.floor(Math.random() * GRID_COLS);
            const ry = Math.floor(Math.random() * GRID_ROWS);
            const px = (rx * ROOM_WIDTH) + 200 + Math.random() * 800;
            const py = (ry * ROOM_HEIGHT) + 200 + Math.random() * 400;
            this.entities.push(new CrewmateNPC(px, py, colors[i % colors.length]));
        }

        document.getElementById('message-overlay').style.display = 'none';
        this.toggleRole(false);
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    }

    toggleRole(forceChange = true) {
        if(forceChange) this.player.isImpostor = !this.player.isImpostor;
        
        const roleBtn = document.getElementById('role-toggle');
        const killBtn = document.getElementById('kill-btn');
        const ventBtn = document.getElementById('vent-btn');
        const actionBtn = document.getElementById('action-btn');

        if (this.player.isImpostor) {
            roleBtn.innerText = "Role: Impostor";
            roleBtn.style.color = "#ff4d4d";
            roleBtn.style.borderColor = "#ff4d4d";
            killBtn.style.display = 'flex';
            ventBtn.style.display = 'flex';
            actionBtn.innerText = "SABOTAGE";
            this.player.color = COLORS.red;
            this.killers = []; 
        } else {
            roleBtn.innerText = "Role: Crewmate (SURVIVE)";
            roleBtn.style.color = "#8cffff";
            roleBtn.style.borderColor = "#8cffff";
            killBtn.style.display = 'none';
            ventBtn.style.display = 'none';
            actionBtn.innerText = "USE";
            this.player.color = COLORS.cyan;
            
            this.killers = [];
            for(let i=0; i<3; i++) {
                const rx = Math.floor(Math.random() * GRID_COLS);
                const ry = Math.floor(Math.random() * GRID_ROWS);
                const px = (rx * ROOM_WIDTH) + 200;
                const py = (ry * ROOM_HEIGHT) + 200;
                this.killers.push(new Killer(px, py));
            }
        }
    }

    startAction() {
        if (this.player.dead || this.player.inVent) return;
        this.actionHeld = true;
        if (!this.player.isImpostor) {
            const nearest = this.getNearest(this.tasks, 60);
            if (nearest && !nearest.completed) this.taskTarget = nearest;
        }
    }

    endAction() {
        this.actionHeld = false;
        this.taskTarget = null;
        this.taskProgress = 0;
        this.updateTaskBar(false); 
    }

    tryKill() {
        if (!this.player.isImpostor || this.player.dead) return;
        const target = this.getNearest(this.entities.filter(d => !d.dead), 80);
        if (target) target.dead = true;
    }

    tryVent() {
        if (!this.player.isImpostor || this.player.dead) return;
        if (this.player.inVent) {
            const currentVent = this.getNearest(this.vents, 9999);
            const nextVent = this.vents.find(v => v.id === currentVent.link);
            this.player.x = nextVent.x;
            this.player.y = nextVent.y;
            this.player.inVent = false;
            this.player.visible = true;
        } else {
            const nearest = this.getNearest(this.vents, 80);
            if (nearest) {
                this.player.x = nearest.x;
                this.player.y = nearest.y;
                this.player.inVent = true;
            }
        }
    }

    getNearest(list, range) {
        let nearest = null;
        let minDst = range;
        for(let item of list) {
            const dx = this.player.x - item.x;
            const dy = this.player.y - item.y;
            const dst = Math.sqrt(dx*dx + dy*dy);
            if (dst < minDst) {
                minDst = dst;
                nearest = item;
            }
        }
        return nearest;
    }

    updateTaskBar(isGlobal = true) {
        const fill = document.getElementById('task-bar-fill');
        const pct = (this.completedTasks / this.totalTasks) * 100;
        fill.style.width = pct + "%";
        if(this.completedTasks >= this.totalTasks) {
            this.gameOver("VICTORY", "crewmate-text");
        }
    }

    gameOver(text, cls) {
        const overlay = document.getElementById('message-overlay');
        const title = document.getElementById('message-title');
        title.innerText = text;
        title.className = cls;
        overlay.style.display = 'flex';
    }

    loop() {
        const now = Date.now();
        let dt = (now - this.lastTime) / 1000;
        dt = Math.min(dt, 0.1); 
        this.lastTime = now;
        this.update(dt);
        this.draw();
        requestAnimationFrame(() => this.loop());
    }

    update(dt) {
        this.player.update(dt, this.input, this.walls);

        // Update Crewmates with Pathfinding
        this.entities.forEach(e => e.update(dt, this.walls, this.player, this.tasks, this.pathfinder));
        
        // Update Killers with Pathfinding
        this.killers.forEach(k => k.update(dt, this.player, this.walls, this.pathfinder));

        if (this.actionHeld && this.taskTarget) {
            this.taskProgress += dt;
            if (this.taskProgress > 1.5) {
                this.taskTarget.completed = true;
                this.completedTasks++;
                this.updateTaskBar();
                this.taskTarget = null;
                this.taskProgress = 0;
                this.actionHeld = false;
            }
        } else {
            this.taskProgress = 0;
        }
    }

    draw() {
        const W = this.canvas.width;
        const H = this.canvas.height;
        this.drawMinimap();

        let camX = W/2 - this.player.x;
        let camY = H/2 - this.player.y;
        camX = Math.min(0, Math.max(W - MAP_WIDTH, camX));
        camY = Math.min(0, Math.max(H - MAP_HEIGHT, camY));

        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(0, 0, W, H);
        
        this.ctx.save();
        this.ctx.translate(camX, camY);

        // Floor (Pattern)
        this.ctx.fillStyle = this.floorPattern;
        this.ctx.fillRect(0, 0, MAP_WIDTH, MAP_HEIGHT);

        // Vents
        this.ctx.fillStyle = '#555';
        for (let v of this.vents) {
            this.ctx.beginPath();
            this.ctx.rect(v.x - 15, v.y - 10, 30, 20);
            this.ctx.fill();
            this.ctx.strokeStyle = '#222';
            this.ctx.stroke();
            this.ctx.beginPath();
            this.ctx.moveTo(v.x-10, v.y-10); this.ctx.lineTo(v.x-10, v.y+10);
            this.ctx.moveTo(v.x, v.y-10); this.ctx.lineTo(v.x, v.y+10);
            this.ctx.moveTo(v.x+10, v.y-10); this.ctx.lineTo(v.x+10, v.y+10);
            this.ctx.stroke();
        }

        // Tasks
        for (let t of this.tasks) {
            this.ctx.fillStyle = t.completed ? '#555' : t.color;
            this.ctx.beginPath();
            this.ctx.rect(t.x - 15, t.y - 15, 30, 30);
            this.ctx.fill();
            if (t === this.taskTarget && this.actionHeld) {
                this.ctx.strokeStyle = 'white';
                this.ctx.lineWidth = 3;
                this.ctx.stroke();
                this.ctx.fillStyle = 'lime';
                this.ctx.fillRect(t.x - 20, t.y - 30, 40 * (this.taskProgress / 1.5), 5);
            }
        }

        const allEntities = [...this.entities, ...this.killers, this.player];
        allEntities.sort((a, b) => a.y - b.y);

        for (let e of allEntities) {
            if (e === this.player && this.player.inVent) continue;
            e.draw(this.ctx);
        }

        this.ctx.fillStyle = WALL_COLOR;
        this.ctx.strokeStyle = '#111';
        this.ctx.lineWidth = 5;
        for (let w of this.walls) {
            this.ctx.fillRect(w.x, w.y, w.w, w.h);
            this.ctx.strokeRect(w.x, w.y, w.w, w.h);
            
            // Wall top texture highlight
            this.ctx.fillStyle = 'rgba(255,255,255,0.1)';
            this.ctx.fillRect(w.x, w.y, w.w, 10);
            this.ctx.fillStyle = WALL_COLOR;
        }
        
        this.ctx.strokeStyle = '#333';
        this.ctx.lineWidth = 20;
        this.ctx.strokeRect(0,0,MAP_WIDTH, MAP_HEIGHT);

        // Optional: Debug Grid
        // this.ctx.strokeStyle = 'rgba(255,0,0,0.2)';
        // this.ctx.lineWidth = 1;
        // for(let i=0; i<this.pathfinder.cols; i++) {
        //     for(let j=0; j<this.pathfinder.rows; j++) {
        //         if(this.pathfinder.grid[j*this.pathfinder.cols + i]) {
        //             this.ctx.strokeRect(i*60, j*60, 60, 60);
        //         }
        //     }
        // }

        this.ctx.restore();
    }

    drawMinimap() {
        const ctx = this.miniCtx;
        const w = this.miniCanvas.width;
        const h = this.miniCanvas.height;
        const scaleX = w / MAP_WIDTH;
        const scaleY = h / MAP_HEIGHT;

        ctx.clearRect(0, 0, w, h);
        ctx.save();
        ctx.scale(scaleX, scaleY);

        ctx.fillStyle = '#555'; 
        for(let wall of this.walls) {
             ctx.fillRect(wall.x, wall.y, wall.w, wall.h);
        }

        if (!this.player.isImpostor) {
            ctx.fillStyle = 'yellow';
            for(let t of this.tasks) {
                if(!t.completed) {
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, 60, 0, Math.PI*2); 
                    ctx.fill();
                }
            }
            ctx.fillStyle = 'red';
            for(let k of this.killers) {
                ctx.beginPath();
                ctx.arc(k.x, k.y, 100, 0, Math.PI*2);
                ctx.fill();
            }
        }

        ctx.fillStyle = '#0f0';
        ctx.beginPath();
        ctx.arc(this.player.x, this.player.y, 80, 0, Math.PI*2);
        ctx.fill();

        ctx.restore();
    }
}

const game = new Game();
</script>
</body>
</html>
